##############################################################################
#
#  Copyright (c) 2016-2021 - Sequana Dev Team (https://sequana.readthedocs.io)
#
#  Distributed under the terms of the 3-clause BSD license.
#  The full license is in the LICENSE file, distributed with this software.
#
#  Website:       https://github.com/sequana/sequana
#  Website:       https://github.com/sequana/fastqc
#  Documentation: http://sequana.readthedocs.io
#  Documentation: https://github.com/sequana/multicov/README.rst
##############################################################################
"""Multicov pipeline"""
import sys
import json

from sequana_pipetools import PipelineManager
from sequana_pipetools import snaketools as sm


configfile: "config.yaml"

manager = PipelineManager("multicov", config,  fastq=False)


# check that the input are BED files ?
filenames = list(manager.samples.values())
__coverage__input = filenames


# Get chrom name from the BED files. Assuming only one chromosome per BED file
chrom_names = []
for filename in filenames:
    chrom_name = open(filename, "r").readline().split()[0].strip()
    chrom_names.append(chrom_name)


# Some final and intermediate file patterns
output_directory = "coverage_reports"
__multiqc__output = "multiqc/multiqc_report.html"
__coverage__output_summary = "coverage_reports/{sample}/sequana_summary_coverage.json"
__coverage__output_rois = "coverage_reports/{sample}/rois.csv"


# The pipeline itself, we need the multiqc as final result:
rule pipeline:
    input: __multiqc__output


# the multiqc rule that requires the JSON as input.
rule multiqc:
    input: expand(__coverage__output_summary, sample=chrom_names),
    output: __multiqc__output
    params:
        config=sequana_data("multiqc_config.yaml", "../multiqc")
    shell:
        "multiqc . -m sequana_coverage  -f -c {params.config}"


# The main coverage factory
rule coverage:
    input: __coverage__input
    output:
        __coverage__output_summary,
        __coverage__output_rois
    params:
        window=config['coverage']["window_size"],
        binning=config['coverage']["binning"],
        circular=config['coverage']['circular'],
        mixture_models=config['coverage']['mixture_models'],
        cnv_clustering=config['coverage']['cnv_clustering'],
    run:
        sm.message("Scanning input file. May take time depending on the input file")

        genome = GenomeCov(input[0])

        for index in range(len(genome.chr_list)):
            chromosome = genome.chr_list[index]

            if params.window > len(chromosome.df) / 4:
                NW = int(len(chromosome.df) / 4)
                if NW % 2 == 0:
                    NW += 1
            else:
                NW = params.window

            # then, we run the analysis (median, zscore, rois)
            results = chromosome.run(NW, params.mixture_models,
                                     circular=params.circular,
                                     binning=params.binning,
                                     cnv_delta=params.cnv_clustering)
            ROIs = results.get_rois()
            summary = results.get_summary()

            # and save the results
            try: os.mkdir("coverage_reports/{}".format(chromosome.chrom_name))
            except:pass
            output_json = "{}/{}/sequana_summary_coverage.json".format(
                                output_directory, chromosome.chrom_name)
            output_roi = "{}/{}/rois.csv".format(
                                output_directory, chromosome.chrom_name)

            summary.to_json(output_json)
            ROIs.df.to_csv(output_roi)

            # Finally HTML reports
            from sequana.utils import config as sequana_config
            sequana_config.output_dir = "." #config['coverage']['output_directory']
            datatable = CoverageModule.init_roi_datatable(ROIs)
            ChromosomeCoverageModule(chromosome, datatable,
                    options={"W": NW,
                             "ROIs": ROIs,
                             "k": params.mixture_models,
                             "circular": params.circular})



onsuccess:
    from sequana_pipetools.errors import PipeError
    p = PipeError("multicov")
    p.status()

